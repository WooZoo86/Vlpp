/***********************************************************************
Author: Zihan Chen (vczh)
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_GLOBALSTORAGE
#define VCZH_GLOBALSTORAGE

#include "Pointer.h"
#include "String.h"

namespace vl
{
	/// <summary>
	/// Base type of all global storages.
	/// A global storage stores multiple values using a name.
	/// The "BEGIN_GLOBAL_STOREGE_CLASS" macro is recommended to create a global storage.
	/// </summary>
	/// <remarks>
	/// All values are shared like global variables, but they are created at the first time when they need to be accessed.
	/// <see cref="FinalizeGlobalStorage"/> is recommended after you don't need any global storages any more, it frees memory.
	/// </remarks>
	/// <example>
	/// BEGIN_GLOBAL_STOREGE_CLASS(MyStorage)
	///     Ptr<vint> data;
	/// INITIALIZE_GLOBAL_STORAGE_CLASS
	///     data = new vint(100);
	/// FINALIZE_GLOBAL_STORAGE_CLASS
	///     data = nullptr;
	/// END_GLOBAL_STORAGE_CLASS(MyStorage)
	///
	/// int main()
	/// {
	///     // GetMyStorage is generated by defining MyStorage
	///     Console::WriteLine(itow(*GetMyStorage().data.Obj()));
	///     FinalizeGlobalStorage();
	/// }
	/// Then you have a global storage. You can only use this global storage in the current cpp file. [M:vl.InitializeGlobalStorage] should be called before using any global storage. [M:vl.FinalizeGlobalStorage] is encouraged to call if you think you will not use any global storages anymore. It will reduce noices when you want to detect memory leaks.
	/// If the key of the global variable is called Key, and the variable you want to access is called Variable, then you can use GetKey()->Variable to access that variable. The GetKey function is created in the macro calls before.
	/// </example>
	class GlobalStorage : public Object, private NotCopyable
	{
	private:
		bool					cleared = false;
	public:
		GlobalStorage(const wchar_t* key);
		~GlobalStorage();

		bool					Cleared();
		virtual void			ClearResource() = 0;
	};

	extern GlobalStorage* GetGlobalStorage(const wchar_t* key);
	extern GlobalStorage* GetGlobalStorage(const WString& key);

	extern void InitializeGlobalStorage();
	/// <summary>Free all memories used by global storages.</summary>
	extern void FinalizeGlobalStorage();
}

#define BEGIN_GLOBAL_STORAGE_CLASS(NAME)		\
	class NAME : public vl::GlobalStorage		\
	{											\
	public:										\
		NAME()									\
			:vl::GlobalStorage(L ## #NAME)		\
		{										\
			InitializeClearResource();			\
		}										\
		~NAME()									\
		{										\
			if(!Cleared())ClearResource();		\
		}										\

#define INITIALIZE_GLOBAL_STORAGE_CLASS			\
		void InitializeClearResource()			\
		{										\

#define FINALIZE_GLOBAL_STORAGE_CLASS			\
		}										\
		void ClearResource()					\
		{										\

#define END_GLOBAL_STORAGE_CLASS(NAME)			\
		}										\
	};											\
	NAME& Get##NAME()							\
	{											\
		static NAME __global_storage_##NAME;	\
		return __global_storage_##NAME;			\
	}											\

#define EXTERN_GLOBAL_STORAGE_CLASS(NAME)\
	class NAME;\
	extern NAME& Get##NAME();\

#endif
